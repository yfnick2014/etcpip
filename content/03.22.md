#技巧22 不要使用TIME-WAIT ASSASSINATION关闭连接
##什么是TIME-WAIT状态
（1）通常情况下，仅有一方——执行主动关闭操作的一方——进入TIME-WAIT状态。

（2）RFC 793定义MSL为2分钟。在这个定义下，连接在TIME-WAIT状态下保持4分钟。然而，该值在实际中被广泛地忽略掉了。例如，因为BSD派生的系统的MSL是30秒，所以TIME-WAIT状态持续一分钟。其他介于30秒和2分钟的值也很常见。

（3）如果连接处于TIME-WAIT状态期间有段到达，就重新启动一个2MSL计时器。

##为什么需要TIME-WAIT
（1）当由主动关闭方发送最后的ACK消息丢失并导致另一方重新发送FIN消息时，TIME-WAIT维护连接状态。

（2）TIME-WAIT为连接中“离群的段”提供从网络中消息的时间。

如果执行主动关闭的一方不进入TIME-WAIT状态就关闭连接那会发生什么呢？当重传的FIN消息达到时，因为TCP已经不再有连接的信息了，所以它就用RST消息应答，导致对等方进入错误状态而不是有序终止状态。但是如果发送最后ACK消息的一方处于TIME-WAIT状态并仍然记录着连接的信息，它就可以正确地响应来自对等方的FIN消息。

如果最后的ACK消息丢失了而对等方重传了FIN消息，处于TIME-WAIT状态的一方就会再次确认FIN消息。重新启动计时器是为了防止该ACK再次丢失。

TIME-WAIT状态的另一个目的更为重要。因为IP数据报在WAN中可能丢失或者延迟，所以TCP使用正面确认机制重传一定时间内没有被对等方确认的段。如果数据报仅仅是延时而不是丢失，或者是数据报的ACK消息丢失了，重传的数据就可能在原先的数据接收之后到达。TCP注意到延迟数据的序列是在当前接收窗口之外，处理并丢弃延迟的数据。

如果延迟或重传段在连接关闭之后到达时将会发生什么。通常情况下，因为TCP仅仅丢弃该数据并响应RST消息，所以这不会造成任何问题。当RST消息到达发出延时段的主机时，因为该主机也没有记录该连接的任何信息，所以它也丢弃该段。然而，如果两个相同主机之间又建立了一个具有相同端口号的新连接，那么离群的段就可能被看成是属于新连接的。如果离群的段中数据的任何序列号恰好处在新连接的当前接收窗口中，数据就会被新连接接收，其结果是破坏新连接。

TIME-WAIT状态通过确保旧套接字对在旧连接的段在网络上消失之前不会被重用来防止这种情况发生的。这样，我们可以看到TIME-WAIT状态在提供TCP的可靠性方面扮演者十分重要的角色。如果没有TIME-WAIT状态，TCP就不能保证“以顺序的方式不被破坏地”递交数据。

##TIME-WAIT Assassination
然而，确实存在过早关闭TIME-OUT状态的可能性，这种情况称作TIME-OUT assassination。

RFC 793指出当连接处于TIME-WAIT状态并接收到一个RST消息时，TCP应当立即关闭连接。假定有一个连接处于TIME-WAIT状态，这时就会有一个TCP不可接受的旧的重复段到达。TCP响应一个ACK消息，指示它能接受的序列号。然而，对等方因为不要有连接的任何信息，所以以RST消息响应该ACK。当该RST到达连接处于TIME-WAIT状态的主机时，它就会导致立即关闭连接——TIME-OUT状态自杀了。

RFC 1337中描述了这种可能性，该文档还讨论了TIME-WAIT assassination的危害。这些危害影响了旧连接的再生，并且有可能导致旧数据的错误接收，导致发生无限ACK消息循环的连接不同步，以及新连接的错误终止。

幸运的是，可以通过改变TCP处于TIME-WAIT状态时忽略RST消息来很容易地防止这种情况发生。

发生TIME-WAIT assassination的另一种途径是人为的。通过使用SO_LINGER套接字选项，程序员可以强制关闭连接，甚至在应用程序正在执行主动关闭时也可以这样。这种不可靠的方法有时被建议用作让服务器从TIME-WAIT状态恢复以使它能从崩溃或中断之后重新启动的一种方法。健壮的应用程序永远不应该干涉TIME-WAIT状态——它是TCP可靠性机制的一个重要部分。

通常情况下，当应用程序关闭连接时，close或closesocket调用会立即返回，即使是发送缓冲区中仍有等待传输的数据时也同样如此。当然，TCP仍然会试图递交没有发送的数据，但是应用程序并不知道递交是否成功。为了防止这个问题发生，可以设置SO_LINGER套接字选项。为了达到这个目的，必须填充linger结构并以SO_LINGER调用setsockopt。

```C
struct linger {
	int l_onoff;  /* option on/off */
	int l_linger; /* linger time */
};
```

如果l_onoff成员为0，就关闭linger选项，所发生的操作等同于默认的操作——close或closesocket调用立即返回，操作系统内核继续试图递交任何没有发送出去的数据。如果l_onff为非零值，它就为操作系统内核停留的时间间隔，等待任何将要发送和确认的挂起数据。也就是说，close或closesocket直到所有数据被递交或时间间隔到时才会返回。

最后，如果l_linger成员的值为零，连接就异常中断。也就是说，发送一个RST消息给对等方，连接不经过TIME-WAIT状态就立即被关闭。