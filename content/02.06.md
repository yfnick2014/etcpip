#技巧6 记住TCP是一个流协议
TCP是一个流协议，这意味着数据是作为字节流递交给接收者的，没有内在的“消息”或“消息边界”的概念。

实际上，send通常只是拷贝数据到主机A的TCP/IP协议栈里然后返回。如果要发送数据的话，TCP就会决定将要立即发送多少出去。该决定是复杂的，并且依赖于多种因素，如发送窗口、阻塞窗口、路径最大传输单元、以及连接的输出队列上有多少数据正在排队。

通常，主机B上的应用程序在任何给定的recv调用上都不会假定TCP可获得多少数据。例如，当主机B上的应用程序通过发布操作来获得第一个消息时，有可能出现下列四种情况之一：

（1）数据没有为读准备好，应用程序阻塞或者recv返回一个指示说明数据不可获得。严格地说，到底发生什么事情依赖于套接字是否已经标记为阻塞以及主机B上的操作系统时如何定义recv系统调用的语意的。

（2）应用程序获得的是消息M1中的部分数据但不是全部。

（3）应用程序获得且只获得消息M1中的所有数据。

（4）应用程序获得消息M1中的所有数据以及消息M2中的部分数据。

再次提醒你，TCP是一个流协议，虽然数据是在IP数据包中传输的，但是一个数据包中的数据跟调用send函数传递多少数据给TCP没有直接的关系。而且，接收数据的应用程序也没有可靠的办法来决定数据是如何分组打包的，这是因为几个包可能在recv调用之间到达。

TCP记录着它发送了多少字节以及多少字节已经被确认了，而不是它们是如何分组打包的。事实上，一些具体实现可以在一个丢失数据包的重传中发送多于或少于原来数据包中的数据。